import { Client, GatewayIntentBits, Collection, ActivityType } from "discord.js";

import { Bot } from "./structs/Bot";
import * as fs from "node:fs";
import * as path from "node:path";
import express from 'express';

declare module "discord.js" {
  interface Client {
    slashCommands: Collection<string, any>;
  }
}

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => res.json({ status: 'OK', service: 'Discord Bot' }));
app.get('/health', (req, res) => res.json({ status: 'OK' }));

const server = app.listen(PORT, () => {
  console.log(`‚úÖ Health check server en puerto ${PORT}`);
});

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.MessageContent
  ],
  presence: {
    activities: [{ name: 'm√∫sica üéµ', type: ActivityType.Listening }],
    status: 'online'
  }
});

client.slashCommands = new Collection();

async function loadSlashCommands() {
  console.log('üîß Cargando comandos...');
  
  const commandsPath = path.join(process.cwd(), 'dist', 'commands');
  
  console.log(`üîç Buscando en: ${commandsPath}`);
  
  if (!fs.existsSync(commandsPath)) {
    console.error('‚ùå No se encontr√≥ dist/commands');
    return 0;
  }

  const commandFiles = fs.readdirSync(commandsPath).filter(file => 
    file.endsWith('.js') && !file.endsWith('.map')
  );

  console.log(`üìÅ Encontrados ${commandFiles.length} archivos .js`);

  let loadedCount = 0;
  
  for (const file of commandFiles) {
    try {
      const filePath = path.join(commandsPath, file);
      
      const commandModule = require(filePath);
      const command = commandModule.default || commandModule;
      
      if (command && command.data && command.execute) {
        client.slashCommands.set(command.data.name, command);
        console.log(`‚úÖ ${command.data.name}`);
        loadedCount++;
      } else {
        console.log(`‚ö†Ô∏è  ${file} - estructura inv√°lida`);
      }
    } catch (error: any) {
      console.error(`‚ùå Error cargando ${file}:`, error.message);
    }
  }
  
  console.log(`üéâ ${loadedCount}/${commandFiles.length} comandos cargados`);
  return loadedCount;
}

client.once('ready', async () => {
  console.log(`üéâ ${client.user!.tag} conectado a Discord!`);
  
  await loadSlashCommands();
  
  console.log(`ùîπùïñùï•ùïíùîæùïíùïûùïöùïüùïò¬Æ ready!`);
  console.log(`üìä Servidores: ${client.guilds.cache.size}`);
  console.log(`üë• Usuarios: ${client.users.cache.size}`);
  console.log(`üîß Comandos: ${client.slashCommands.size}`);
  
  client.user!.setPresence({
    activities: [{ name: `${client.guilds.cache.size} servidores | /play`, type: ActivityType.Listening }],
    status: 'online'
  });
});

client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand()) return;

  const command = client.slashCommands.get(interaction.commandName);
  
  if (!command) {
    console.error(`‚ùå Comando no encontrado: ${interaction.commandName}`);
    return;
  }

  try {
    await command.execute(interaction);
  } catch (error: any) {
    console.error(`üí• Error en ${interaction.commandName}:`, error);
    
    try {
      if (interaction.replied || interaction.deferred) {
        await interaction.editReply('‚ùå Error ejecutando el comando.');
      } else {
        await interaction.reply({ content: '‚ùå Error ejecutando el comando.', ephemeral: true });
      }
    } catch (replyError) {
      console.error('Error al responder:', replyError);
    }
  }
});

process.on('unhandledRejection', (error) => {
  console.error('üö® UNHANDLED REJECTION:', error);
});

process.on('uncaughtException', (error) => {
  console.error('üí• UNCAUGHT EXCEPTION:', error);
  setTimeout(() => process.exit(1), 1000);
});

process.on('SIGINT', async () => {
  console.log('\nüì¥ Apagando...');
  server.close();
  if (client.isReady()) client.destroy();
  setTimeout(() => process.exit(0), 3000);
});

console.log('üöÄ Inicializando bot...');

export const bot = new Bot(client);

client.login(process.env.TOKEN).catch((error) => {
  console.error('‚ùå Error iniciando sesi√≥n:', error);
  process.exit(1);
});
